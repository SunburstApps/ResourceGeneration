using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

namespace Sunburst.ResourceGeneration
{
    public class GenerateRestextCodeBehindFile : TaskBase
    {
        [Required]
        public ITaskItem[] RestextFiles { get; set; }

        [Required]
        public string Language { get; set; }

        [Output]
        public ITaskItem[] Compile { get; set; }

        [Required]
        public string Visibility { get; set; }

        private static List<(string key, string comment)> ParseRestextFile(TextReader reader)
        {
            List<(string key, string comment)> entries = new List<(string key, string comment)>();

            StringBuilder name = new StringBuilder();
            StringBuilder comment = new StringBuilder();

            bool inComment = false;
            int ch = 0;
            while (ch != -1)
            {
                ch = reader.Read();
                if (ch == '\r' || ch == '\n')
                {
                    inComment = false;
                    continue;
                }

                if ((ch == '#' || ch == ';') && !inComment)
                {
                    inComment = true;
                    comment.Append(' ');
                    continue;
                }

                if (inComment)
                {
                    comment.Append((char)ch);
                }
                else
                {
                    if (ch == '=')
                    {
                        reader.ReadLine();

                        entries.Add((name.ToString().Trim(), comment.ToString().Trim()));
                        name = new StringBuilder();
                        comment = new StringBuilder();
                        continue;
                    }

                    name.Append((char)ch);
                }
            }

            return entries;
        }

        protected override void ExecuteCore()
        {
            // The algorithm used by this class is mostly borrowed from:
            // https://github.com/dotnet/roslyn-tools/blob/master/sdks/RepoToolset/tools/GenerateResxSource.csx,
            // heavily modified for readability.

            bool internalMembers;
            if (Visibility.Equals("Public", StringComparison.OrdinalIgnoreCase))
            {
                internalMembers = false;
            }
            else if (Visibility.Equals("Internal", StringComparison.OrdinalIgnoreCase))
            {
                internalMembers = true;
            }
            else
            {
                throw new BuildErrorException("Visibility must be either Public or Internal");
            }

            List<ITaskItem> outputs = new List<ITaskItem>();

            foreach (ITaskItem item in RestextFiles)
            {
                string codeBehindPath = item.GetMetadata("CodeBehindFile");
                if (string.IsNullOrEmpty(codeBehindPath))
                    throw new BuildErrorException("Item '{0}' does not have CodeBehindFile metadata", item.ItemSpec);

                try
                {
                    if (Language.Equals("C#", StringComparison.OrdinalIgnoreCase))
                    {
                        WriteCSharpCodeBehind(item, codeBehindPath, internalMembers);
                    }
                    else if (Language.Equals("VB", StringComparison.OrdinalIgnoreCase))
                    {
                        WriteVisualBasicCodeBehind(item, codeBehindPath, internalMembers);
                    }
                    else
                    {
                        throw new BuildErrorException($"Unrecognized language '{Language}'");
                    }
                }
                catch (InvalidDataException e)
                {
                    throw new BuildErrorException($"Error parsing file '{item.ItemSpec}': {e.Message}", e);
                }

                ITaskItem output = new TaskItem(codeBehindPath);
                outputs.Add(output);
            }

            Compile = outputs.ToArray();
        }

        private void WriteCSharpCodeBehind(ITaskItem resxFile, string codeBehindFile, bool internalMembers)
        {
            string visibility = internalMembers ? "internal" : "public";
            StringBuilder builder = new StringBuilder();

            builder.AppendLine("// <auto-generated />");
            builder.AppendLine("using System.Reflection;");
            builder.AppendLine();

            string resourceName = resxFile.GetMetadata("ManifestResourceName");
            string[] nameParts = resourceName.Split('.');
            string namespaceName, className, classIndent;
            if (nameParts.Length > 1)
            {
                namespaceName = string.Join(".", nameParts, 0, nameParts.Length - 1);
                className = nameParts.Last();
                classIndent = "    ";
            }
            else
            {
                namespaceName = null;
                className = nameParts[0];
                classIndent = "";
            }

            string memberIndent = classIndent + "    ";

            if (namespaceName != null)
            {
                builder.AppendLine($"namespace {namespaceName}");
                builder.AppendLine("{");
            }

            builder.AppendLine($"{classIndent}{visibility} static class {className}");
            builder.AppendLine($"{classIndent}{{");

            builder.AppendLine($"{memberIndent}{visibility} static global::System.Globalization.CultureInfo Culture {{ get; set; }}");
            builder.AppendLine($"{memberIndent}{visibility} static global::System.Resources.ResourceManager ResourceManager {{ get; }} = new global::System.Resources.ResourceManager(\"{resourceName}\", typeof({className}).GetTypeInfo().Assembly);");
            builder.AppendLine();

            List<(string key, string comment)> restextContent;
            using (var reader = new StreamReader(resxFile.ItemSpec))
                restextContent = ParseRestextFile(reader);

            foreach ((var name, var comment) in restextContent)
            {
                if (name == "") throw new BuildErrorException("Empty resource name");

                if (!string.IsNullOrWhiteSpace(comment))
                {
                    builder.AppendLine($"{memberIndent}/// <summary>");
                    builder.AppendLine($"{memberIndent}/// {comment}");
                    builder.AppendLine($"{memberIndent}/// </summary>");
                }

                string identifier = Utilities.CreateValidCSharpIdentifier(name);
                builder.AppendLine($"{memberIndent}{visibility} static string {identifier} => ResourceManager.GetString(\"{name}\", Culture);");
            }

            builder.AppendLine($"{classIndent}}}");

            if (namespaceName != null)
                builder.AppendLine("}");

            File.WriteAllText(codeBehindFile, builder.ToString());
        }

        private void WriteVisualBasicCodeBehind(ITaskItem resxFile, string codeBehindFile, bool internalMembers)
        {
            string visibility = internalMembers ? "Friend" : "Public";
            StringBuilder builder = new StringBuilder();

            builder.AppendLine("' <auto-generated />");
            builder.AppendLine("Imports System.Reflection");
            builder.AppendLine();

            string resourceName = resxFile.GetMetadata("ManifestResourceName");
            string[] nameParts = resourceName.Split('.');
            string namespaceName, className, classIndent;
            if (nameParts.Length > 1)
            {
                namespaceName = string.Join(".", nameParts, 0, nameParts.Length - 1);
                className = nameParts.Last();
                classIndent = "    ";
            }
            else
            {
                namespaceName = null;
                className = nameParts[0];
                classIndent = "";
            }

            string memberIndent = classIndent + "    ";

            if (namespaceName != null)
                builder.AppendLine($"Namespace {namespaceName}");

            builder.AppendLine($"{classIndent}{visibility} Class {className}");
            builder.AppendLine($"{memberIndent}Private Sub New()");
            builder.AppendLine($"{memberIndent}End Sub");
            builder.AppendLine();

            builder.AppendLine($"{memberIndent}{visibility} Shared Property Culture As Global.System.Globalization.CultureInfo");
            builder.AppendLine($"{memberIndent}{visibility} Shared ReadOnly Property ResourceManager As New Global.System.Resources.ResourceManager ResourceManager(\"{resourceName}\", GetType({className}).GetTypeInfo().Assembly);");
            builder.AppendLine();

            List<(string key, string comment)> restextContent;
            using (var reader = new StreamReader(resxFile.ItemSpec))
                restextContent = ParseRestextFile(reader);

            foreach ((var name, var comment) in restextContent)
            {
                if (name == "") throw new BuildErrorException("Empty resource name");

                if (!string.IsNullOrWhiteSpace(comment))
                {
                    builder.AppendLine($"{memberIndent}''' <summary>");
                    builder.AppendLine($"{memberIndent}''' {comment}");
                    builder.AppendLine($"{memberIndent}''' </summary>");
                }

                string identifier = Utilities.CreateValidVisualBasicIdentifier(name);
                builder.AppendLine($"{memberIndent}{visibility} Shared ReadOnly Property {identifier} As String");
                builder.AppendLine($"{memberIndent}    Get");
                builder.AppendLine($"{memberIndent}        Return ResourceManager.GetString(\"{name}\", Culture)");
                builder.AppendLine($"{memberIndent}    End Get");
                builder.AppendLine($"{memberIndent}End Property");
                builder.AppendLine();
            }

            builder.Append($"{classIndent}End Class");

            if (namespaceName != null)
                builder.AppendLine("End Namespace");

            File.WriteAllText(codeBehindFile, builder.ToString());
        }
    }
}